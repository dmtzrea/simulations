beta <- suppressWarnings(MMLQR.cens(yt,deltat,xt,tau,initial,h=h,toler=1e-6)$beta) # bigger tolerance than for real estimation to save time
pred <- beta[1]+xv*beta[-1]
ind2      <- which(deltav==1)
tmp.error <- sum((yv[ind2]-pred[ind2])*(tau-as.numeric(yv[ind2]<=pred[ind2])))  #absolute prediction error based on the ith validation sample
fpred.5cv <- c(fpred.5cv, tmp.error)
}
result<- mean(fpred.5cv)
result
}
# MM algorithm for CQR (multivariate)
MMLQR.cens.multi <- function(Y,delta,X,tau,beta,h,toler=1e-10,maxit=5000){
require(survival)
iteration <- 0
n.obs     <- length(Y)
df.mat    <- cbind(rep(1,n.obs),X)
# Calculation of epsilon
tn        <- toler/n.obs
e0        <- -tn/log(tn)
eps       <- (e0-tn)/(1+log(e0))
# Conditional Kaplan-Meier for G_C(.|X) (same code as Wang et al.)
tauhat.func  <- function(y0, x0, y, x, delta, h, kernel.type="4th"){
# estimate the cond. censoring probability P(T<y0|x0)
# x0: k-dimensional covariate vector
# y: observed survival time = T^C, n-vector
# x: k-dimensional covariate, n*k matrix
Univ.Kernel.func <- function(x0, x, h, kernel.type){
# the kernel weight function Bnk(x0, x), where x0 is a scalar, and x is a vector
# returns a vector
# h is the bandwidth
xx<-(x-x0)/h
if(kernel.type=="normal")
{
w=dnorm(xx)
}
if(kernel.type=="4th")
{
xx[abs(xx)>=1]<-1
w<-105*(1-5*xx^2+7*xx^4-3*xx^6)/64  #biquadratic kernel
}
w<-w/ifelse(sum(w)==0,1,sum(w))
return(w)
}
Kernel.func      <- function(U, U0, h, kernel.type){
# U: n*k matrix
# U0: k-vector
# return: K((U-U0)/h)
n = nrow(U)
if(kernel.type=="4th")
{
tt = rbind(U, U0)
tmp = apply(tt, 2, function(x)
{
Univ.Kernel.func(x[1:n],x[n+1],h,kernel.type)
})
tmp = apply(tmp, 1, prod)
tmp = tmp/sum(tmp)
}
if(kernel.type=="normal") # use multivariate normal density as the kernel function
{
k = length(U0)
tt = t(t(U)-U0)/h
tmp = dmvnorm(tt, mean=rep(0,k), sigma=diag(k), log=FALSE)
tmp = tmp/sum(tmp)
}
return(tmp)
}
# this is the same for model1 with interaction, and model2: without interaction
n<-length(y)
w<-rep(0,n)
# modified by Huixia on 04/15/2008
p = qr(x)$rank
if(p>1)  Bn = Kernel.func(x, x0, h, kernel.type)
if(p==1) Bn = Univ.Kernel.func(x, x0, h, kernel.type)
if (y0<max(y))
{
# sort the data y, and the delta, Bn correspondingly to the order of sorted y
y2     = sort(y)
Order  = order(y) # so y[Order] = z2
Bn2    = Bn[Order]
delta2 = delta[Order]
eta    = which(delta2==1 & y2<=y0) # the index of those observations satisfying delta2==1 & y2<=y0
Bn3    = Bn2[n:1]  # change the order of Bn2, make the first obs of Bn2 to be the last of Bn3
tmp    = 1- Bn2 /cumsum(Bn3)[n:1]
out    = 1-prod(tmp[eta], na.rm=T) # na.rm=T, as some of those tmp=NA as the denom =0
}
else out=1
out
}
Beran.fun    <- function(a,h){ # rewritten to use apply on rows of matrix of (beta X,X) in MM afterwards
tauhat.func(a[1],a[2:(dim(X)[2]+1)], Y, X, 1-delta,h)
}
# Initialization of condition for break
cond <- T
while(cond)
{
beta.prev <- beta
r.vec     <- Y-df.mat%*%as.matrix(beta)
A.entries <- c(1/(eps+abs(r.vec)))/2
A.mat     <- diag(A.entries)
B.mat     <- as.matrix(rep(tau-.5,n.obs))
G.mat     <- as.matrix((1-tau)*apply(cbind(df.mat%*%as.matrix(beta.prev),X),1,FUN="Beran.fun",h=h))
beta      <- solve(t(df.mat)%*%A.mat%*%df.mat)%*%(t(df.mat)%*%(A.mat%*%as.matrix(Y)+B.mat+G.mat))
cond      <- max(abs(beta-beta.prev)) > toler
iteration <- iteration + 1
if(iteration > maxit){warning("WARNING: Algorithm did not converge"); break}
}
return(list("beta"=c(beta),"IterN"=iteration))
}
# CV for MM algo with Beran (multivariate)
MM.multi.cv <- function(Y,X,delta, nfold=5, h, tau,initial){
# cross validation for selecting the bandwidth
n <- length(Y)
m <- n/nfold
pp  <- 1:n
pp1 <- sample(pp)   ##a random permutation of 1:n
fpred.5cv = NULL
for (i in 1:nfold)
{
#validation data
ind    <- pp1[seq((i-1)*m+1,i*m,1)]
xv     <- X[ind,]
yv     <- Y[ind]
deltav <- delta[ind]
#training data
xt     <- X[-ind,]
yt     <- Y[-ind]
deltat <- delta[-ind]
beta <- suppressWarnings(MMLQR.cens.Gcond(yt,deltat,xt,tau,initial,h=h,toler=1e-6)$beta) # bigger tolerance than for real estimation to save time
pred <- beta[1]+xv*beta[-1]
ind2      <- which(deltav==1)
tmp.error <- sum((yv[ind2]-pred[ind2])*(tau-as.numeric(yv[ind2]<=pred[ind2])))  #absolute prediction error based on the ith validation sample
fpred.5cv <- c(fpred.5cv, tmp.error)
}
result<- mean(fpred.5cv)
result
}
# retinopathy ----
data(retinopathy)
force(retinopathy)
# retinopathy ----
data(retinopathy)
X = as.matrix(cbind(rep(1, nrow(retinopathy)), retinopathy$age))
X_s = as.matrix(retinopathy %>% select(age,trt))
m = 2
m_tilde = 2
H=4
type=c('Laguerre', 'Laguerre', 'Laguerre')
Y=(retinopathy$futime)
Delta=retinopathy$status
tau=0.5
verbose = 2
link="exp"
starting_beta = FALSE
trials = 2000
id = function(x){return(x)}
idd = function(x){return(x^0)}
link = list(id, idd)
id = function(x){return(abs(x))}
idd = function(x){return(ifelse(x>=0, 1, -1))}
link2 = list(id, idd)
# Bandwidth CV----
h.vect.WW <- seq(0.05, .5, length=15)
cv.WW     <- NULL
for (j in 1:length(h.vect.WW)){
h.temp <- h.vect.WW[j]
tmp.cv <- WW.cv(Y,X[,2], Delta, nfold=5, h.temp, tau)
cv.WW  <- c(cv.WW, tmp.cv)
}
h.WW  <- h.vect.WW[which.min(cv.WW)]
bfeed_pov = laguerre_estimator_het(2,2,3,X,X_s,type=c('Laguerre', 'Laguerre', 'Laguerre'),Y=Y, Delta=Delta, tau=0.5,
verbose = 1, link="exp", trials=trials)
crq = crq(Surv(Y,Delta, type='right')~X[,2], tau=tau, method = "Portnoy")
estexp = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=1,link="exp"))
while(estexp$objective %in% c(-Inf, Inf)){
estexp = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=1,link="exp"))
}
estquad = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=1,link="quad"))
while(estquad$objective %in% c(-Inf, Inf)){
estquad = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=1,link="quad"))
}
est_id = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=1,link=link))
while(est_id$objective %in% c(-Inf, Inf)){
est_id = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=1,link=link))
}
est_abs = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=1,link=link2))
while(est_abs$objective %in% c(-Inf, Inf)){
est_abs = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=1,link=link2))
}
beta_h = laguerre_estimator_het(m,m_tilde,0, X=X,X_s,type, Y=Y, Delta=Delta, tau=tau,trials=32, verbose = 1)$beta
adapted = MMLQR.cens(Y,Delta,X[,2],tau,h=0.5, beta=c(4,5))
W.W = WW.cens(Y, X[,2], Delta, tau, 0.1)
W.W_cv = WW.cens(Y, X[,2], Delta, tau, h.WW)
PHuang = PH.cens(Y, Delta, tau, X[,2])
### Collecting the results
PHuang
W.W$coeff
W.W_cv$coeff
adapted$beta
crq$sol[2:3,which.min(abs(tau - crq$sol["tau",]))]
beta_h
estexp$beta
bfeed_pov$beta
estquad$beta
est_id$beta
est_abs$beta
graph(bfeed_pov)
graph(estexp)
graph(estquad)
graph(est_id)
graph(est_abs)
# retinopathy ----
data(retinopathy)
X = as.matrix(cbind(rep(1, nrow(retinopathy)), retinopathy$age))
X_s = as.matrix(retinopathy %>% select(age))
m = 2
m_tilde = 2
H=4
type=c('Laguerre', 'Laguerre', 'Laguerre')
Y=(retinopathy$futime)
Delta=retinopathy$status
tau=0.5
verbose = 2
link="exp"
starting_beta = FALSE
trials = 2000
## Identity link ----
id = function(x){return(x)}
idd = function(x){return(x^0)}
link = list(id, idd)
## absolute value link ----
id = function(x){return(abs(x))}
idd = function(x){return(ifelse(x>=0, 1, -1))}
link2 = list(id, idd)
# Bandwidth CV----
h.vect.WW <- seq(0.05, .5, length=15)
cv.WW     <- NULL
for (j in 1:length(h.vect.WW)){
h.temp <- h.vect.WW[j]
tmp.cv <- WW.cv(Y,X[,2], Delta, nfold=5, h.temp, tau)
cv.WW  <- c(cv.WW, tmp.cv)
}
h.WW  <- h.vect.WW[which.min(cv.WW)]
# estimators ----
bfeed_pov = laguerre_estimator_het(2,2,3,X,X_s,type=c('Laguerre', 'Laguerre', 'Laguerre'),Y=Y, Delta=Delta, tau=0.5,
verbose = 1, link="exp", trials=trials)
crq = crq(Surv(Y,Delta, type='right')~X[,2], tau=tau, method = "Portnoy")
estexp = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=1,link="exp"))
while(estexp$objective %in% c(-Inf, Inf)){
estexp = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=1,link="exp"))
}
estquad = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=1,link="quad"))
while(estquad$objective %in% c(-Inf, Inf)){
estquad = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=1,link="quad"))
}
est_id = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=1,link=link))
while(est_id$objective %in% c(-Inf, Inf)){
est_id = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=1,link=link))
}
est_abs = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=1,link=link2))
while(est_abs$objective %in% c(-Inf, Inf)){
est_abs = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=1,link=link2))
}
beta_h = laguerre_estimator_het(m,m_tilde,0, X=X,X_s,type, Y=Y, Delta=Delta, tau=tau,trials=32, verbose = 1)$beta
adapted = MMLQR.cens(Y,Delta,X[,2],tau,h=0.5, beta=c(4,5))
beta_h
estexp$beta
bfeed_pov$beta
estquad$beta
est_id$beta
est_abs$beta
crq$sol[2:3,which.min(abs(tau - crq$sol["tau",]))]
graph(bfeed_pov)
graph(estexp)
graph(estquad)
graph(est_id)
graph(est_abs)
max(runif(200, min=-1, max = 1))
min(runif(200, min=-1, max = 1))
(runif(200, min=-1, max = 1))
min(runif(200, min=-1, max = 1))
min(runif(200, min=-1, max = 1))
min(runif(200, min=-1, max = 1))
min(runif(200, min=-1, max = 1))
min(runif(200, min=-1, max = 1))
min(runif(200, min=-1, max = 1))
min(runif(200, min=-1, max = 1))
min(runif(200, min=-1, max = 1))
min(runif(200, min=-1, max = 1))
min(runif(200, min=-1, max = 1))
min(runif(200, min=-1, max = 1))
min(runif(200, min=-1, max = 1))
Y=bfeed$duration
min(runif(200, min=-1, max = 1))
min(runif(200, min=-1, max = 1))
min(runif(200, min=-1, max = 1))
min(runif(200, min=-1, max = 1))
min(runif(200, min=-1, max = 1))
min(runif(200, min=-1, max = 1))
min(runif(200, min=-1, max = 1))
min(runif(200, min=-1, max = 1))
min(runif(200, min=-1, max = 1))
max(runif(200, min=-1, max = 1))
max(runif(200, min=-1, max = 1))
max(runif(200, min=-1, max = 1))
max(runif(200, min=-1, max = 1))
max(runif(200, min=-1, max = 1))
max(runif(200, min=-1, max = 1))
max(runif(200, min=-1, max = 1))
max(runif(200, min=-1, max = 1))
max(runif(200, min=-1, max = 1))
max(runif(200, min=-1, max = 1))
max(runif(200, min=-1, max = 1))
max(runif(200, min=-1, max = 1))
max(runif(200, min=-1, max = 1))
max(runif(200, min=-1, max = 1))
# Function to check libraries----
package_load<-function(packages = NULL, quiet=TRUE,
verbose=FALSE, warn.conflicts=FALSE){
# download required packages if they're not already
pkgsToDownload<- packages[!(packages  %in% installed.packages()[,"Package"])]
if(length(pkgsToDownload)>0)
install.packages(pkgsToDownload, repos="http://cran.us.r-project.org",
quiet=quiet, verbose=verbose)
# then load them
for(i in 1:length(packages))
require(packages[i], character.only=T, quietly=quiet,
warn.conflicts=warn.conflicts)
}
## Load Libraries ----
package_load(c('abind', 'foreach', 'doParallel', 'dplyr', 'devtools', 'pracma',
'tidyr', 'ggplot2', 'kableExtra','quantreg', 'survival',
'orthopolynom', 'EQL', 'nloptr', 'SphericalCubature', 'polynom'))
install_github("dmtzrea/Laguerre2")
library(Laguerre)
## SET WD  ----
# sets wd to the path where this script lives
setwd(dir = dirname(rstudioapi::getSourceEditorContext()$path))
## Find the number of cores in your system ----
clno <- detectCores()
cl   <- makeCluster(clno,outfile="test2")
registerDoParallel(cl)
## LOAD LITERATURE AND DATASETS ----
source(file = "Loading Literature.R")
source(file = "DGP5.R")
## Identity link ----
id = function(x){return(x)}
idd = function(x){return(x^0)}
link = list(id, idd)
## absolute value link ----
id = function(x){return(abs(x))}
idd = function(x){return(ifelse(x>=0, 1, -1))}
link2 = list(id, idd)
# Initialize list ----
h_list = vector(mode = "list", length = length(h))
i=300
k=1
H=5
X = datasets[[k]][,1:2,i]
Y = datasets[[k]][,4,i]
Delta = datasets[[k]][,5,i]
T = datasets[[k]][,6,i]
X_s = as.matrix(datasets[[k]][,2, i])
tau  <- matrix[k, 3]
# Bandwidth CV
h.vect.WW <- seq(0.05, .5, length=15)
cv.WW     <- NULL
for (j in 1:length(h.vect.WW)){
h.temp <- h.vect.WW[j]
tmp.cv <- WW.cv(Y,X[,2], Delta, nfold=5, h.temp, tau)
cv.WW  <- c(cv.WW, tmp.cv)
}
h.WW  <- h.vect.WW[which.min(cv.WW)]
omni = rq(T~X[,2], tau = tau)
crq = crq(Surv(Y,Delta, type='right')~X[,2], tau=tau, method = "Portnoy")
estexp = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=0,link="exp"))
while(estexp$objective %in% c(-Inf, Inf)){
estexp = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=0,link="exp"))
}
estquad = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=0,link="quad"))
while(estquad$objective %in% c(-Inf, Inf)){
estquad = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=0,link="quad"))
}
est_id = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=0,link=link))
while(est_id$objective %in% c(-Inf, Inf)){
est_id = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=0,link=link))
}
est_abs = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=0,link=link2))
while(est_abs$objective %in% c(-Inf, Inf)){
est_abs = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=0,link=link2))
}
beta_h = laguerre_estimator_het(m,m_tilde,0, X=X,X_s,type, Y=Y, Delta=Delta, tau=tau,trials=32, verbose = 0)
adapted = MMLQR.cens(Y,Delta,X[,2],tau,h=0.5, beta=c(4,5))
W.W = WW.cens(Y, X[,2], Delta, tau, 0.1)
W.W_cv = WW.cens(Y, X[,2], Delta, tau, h.WW)
PHuang = PH.cens(Y, Delta, tau, X[,2])
crq$sol[2:3,which.min(abs(tau - crq$sol["tau",]))]
beta_h$beta
estexp$beta
estquad$beta
est_id$beta
est_abs$beta
graph(est_abs)
matrix
for (H in h){
out7 =
foreach(k = 1:(dim(matrix)[1]), .combine = 'cube', .packages = 'abind', .multicombine = TRUE)%:%
foreach(i=1:(dim(datasets[[k]])[3]),.packages=c('nloptr','SphericalCubature', 'EQL','orthopolynom',
'quantreg', 'survival', 'Laguerre'),
.combine=rbind) %dopar% {
### setting random seed
set.seed(seeds[which(h==H,arr.ind = TRUE), k, i])
cat("Step ",i," of ",matrix[k,"N"]," from simulation ",k, " ", "h = ", H, "\n")
X = datasets[[k]][,1:2,i]
Y = datasets[[k]][,4,i]
Delta = datasets[[k]][,5,i]
T = datasets[[k]][,6,i]
X_s = as.matrix(datasets[[k]][,2, i])
tau  <- matrix[k, 3]
# Bandwidth CV
h.vect.WW <- seq(0.05, .5, length=15)
cv.WW     <- NULL
for (j in 1:length(h.vect.WW)){
h.temp <- h.vect.WW[j]
tmp.cv <- WW.cv(Y,X[,2], Delta, nfold=5, h.temp, tau)
cv.WW  <- c(cv.WW, tmp.cv)
}
h.WW  <- h.vect.WW[which.min(cv.WW)]
omni = rq(T~X[,2], tau = tau)
crq = crq(Surv(Y,Delta, type='right')~X[,2], tau=tau, method = "Portnoy")
estexp = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=0,link="exp"))
while(estexp$objective %in% c(-Inf, Inf)){
estexp = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=0,link="exp"))
}
estquad = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=0,link="quad"))
while(estquad$objective %in% c(-Inf, Inf)){
estquad = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=0,link="quad"))
}
est_id = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=0,link=link))
while(est_id$objective %in% c(-Inf, Inf)){
est_id = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=0,link=link))
}
est_abs = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=0,link=link2))
while(est_abs$objective %in% c(-Inf, Inf)){
est_abs = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=0,link=link2))
}
beta_h = laguerre_estimator_het(m,m_tilde,0, X=X,X_s,type, Y=Y, Delta=Delta, tau=tau,trials=32, verbose = 0)
adapted = MMLQR.cens(Y,Delta,X[,2],tau,h=0.5, beta=c(4,5))
W.W = WW.cens(Y, X[,2], Delta, tau, 0.1)
W.W_cv = WW.cens(Y, X[,2], Delta, tau, h.WW)
PHuang = PH.cens(Y, Delta, tau, X[,2])
### Collecting the results
c(omni$coefficients,
PHuang,
W.W$coeff,
W.W_cv$coeff,
crq$sol[2:3,which.min(abs(tau - crq$sol["tau",]))],
adapted$beta,
beta_h$beta,
estexp$beta,estquad$beta, est_id$beta, est_abs$beta,
estexp$H, estquad$H, est_id$H, est_abs$H,
estexp$theta, estquad$theta, est_id$theta, est_abs$theta,
estexp$theta_tilde, estquad$theta_tilde, est_id$theta_tilde, est_abs$theta_tilde)
}
h_list[[which(h==H,arr.ind = TRUE)]] = out7
}
i=28
k=1
X = datasets[[k]][,1:2,i]
Y = datasets[[k]][,4,i]
Delta = datasets[[k]][,5,i]
T = datasets[[k]][,6,i]
X_s = as.matrix(datasets[[k]][,2, i])
tau  <- matrix[k, 3]
# Bandwidth CV
h.vect.WW <- seq(0.05, .5, length=15)
cv.WW     <- NULL
for (j in 1:length(h.vect.WW)){
h.temp <- h.vect.WW[j]
tmp.cv <- WW.cv(Y,X[,2], Delta, nfold=5, h.temp, tau)
cv.WW  <- c(cv.WW, tmp.cv)
}
h.WW  <- h.vect.WW[which.min(cv.WW)]
omni = rq(T~X[,2], tau = tau)
crq = crq(Surv(Y,Delta, type='right')~X[,2], tau=tau, method = "Portnoy")
estexp = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=0,link="exp"))
while(estexp$objective %in% c(-Inf, Inf)){
estexp = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=0,link="exp"))
}
estquad = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=0,link="quad"))
while(estquad$objective %in% c(-Inf, Inf)){
estquad = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=0,link="quad"))
}
est_id = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=0,link=link))
while(est_id$objective %in% c(-Inf, Inf)){
est_id = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=0,link=link))
}
est_abs = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=0,link=link2))
while(est_abs$objective %in% c(-Inf, Inf)){
est_abs = try(laguerre_estimator_het(m,m_tilde,H,X,X_s,type, Y, Delta, tau,trials=32, verbose=0,link=link2))
}
beta_h = laguerre_estimator_het(m,m_tilde,0, X=X,X_s,type, Y=Y, Delta=Delta, tau=tau,trials=32, verbose = 0)
adapted = MMLQR.cens(Y,Delta,X[,2],tau,h=0.5, beta=c(4,5))
W.W = WW.cens(Y, X[,2], Delta, tau, 0.1)
W.W_cv = WW.cens(Y, X[,2], Delta, tau, h.WW)
PHuang = PH.cens(Y, Delta, tau, X[,2])
crq$sol[2:3,which.min(abs(tau - crq$sol["tau",]))]
beta_h$beta
estexp$beta
estquad$beta
est_id$beta
est_abs$beta
graph(estexp)
